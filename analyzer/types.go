package analyzer

import (
	"fmt"
	"strings"
)

// Report is the end result of an analysis containing the files analyzed,
// the issues searched for and a map of findings per issue.
type Report struct {
	Issues        []Issue
	FilesAnalyzed []string
	// Key is Issue Identifier
	FindingsPerIssue map[string][]Finding
}

// Issue represents an Issue to search for in the codebase.
// The pattern field is a RegEx string which must compile.
type Issue struct {
	Identifier string
	Severity   Severity
	Title      string
	Link       string
	Pattern    string
}

// Finding represents a possible Issue found in the codebase.
type Finding struct {
	IssueIdentifier string
	File            string
	LineNumber      int
	LineContent     string
}

// Severity type defining the severity level for an Issue.
type Severity int

// The Severity Enum.
const (
	GASOP Severity = iota
	NC
	LOW
	MEDIUM
	HIGH
)

// Markdown returns the report as string in markdown style.
func (r Report) Markdown(contractName string, botName string) string {
	const c4uditRepoLink = "https://github.com/danMendes-bossanova/c4uditd"
	// Issue output in Code4Rena format:
	// ### {{ issue.Title }}
	//
	// #### Impact
	// Issue information: [{{ issue.Identifier }}]({{ issue.Link }})
	//
	// #### Findings
	// {{ _, finding := range findings: finding.String() }}
	//
	// #### Tools used
	// [c4udit]({{ c4uditRepoLink }})
	//
	buf := strings.Builder{}

	buf.WriteString(fmt.Sprintf("# Audit report for %s generated by %s\n", contractName, botName))
	buf.WriteString("\n")

	buf.WriteString("# c4udit Report\n")
	buf.WriteString("\n")

	buf.WriteString("## Summary\n")
	buf.WriteString("\n")

	// // Count issues by severity
	// severityCounts := map[Severity]int{}
	// for _, issue := range r.Issues {
	// 	severityCounts[issue.Severity]++
	// }

	// // Add table header
	// buf.WriteString("| Severity | Count |\n")
	// buf.WriteString("| -------- | ----- |\n")

	// // Add summary for each severity level
	// for i := GASOP; i <= HIGH; i++ {
	// 	count := severityCounts[i]
	// 	if count > 0 {
	// 		buf.WriteString(fmt.Sprintf("| %s | %d |\n", i.String(), count))
	// 	}
	// }

	// buf.WriteString("\n")

	// Count issues by severity
	severityCounts := map[Severity]int{}
	for _, issue := range r.Issues {
		severityCounts[issue.Severity]++
	}

	// Add summary for each severity level
	for i := GASOP; i <= HIGH; i++ {
		issues := filterIssuesBySeverity(r.Issues, i)
		if len(issues) == 0 {
			continue
		}

		// Add severity level header
		buf.WriteString(fmt.Sprintf("### %s Issues\n", i.String()))

		// Calculate total instances and issues
		totalInstances := 0
		for _, issue := range issues {
			totalInstances += len(r.FindingsPerIssue[issue.Identifier])
		}

		buf.WriteString(fmt.Sprintf("Total **%d instances** over **%d issues**:\n", totalInstances, len(issues)))

		// Add table header
		buf.WriteString("|ID|Issue|Instances|\n")
		buf.WriteString("|:--:|:---|:--:|\n")

		// Add issue rows
		for _, issue := range issues {
			instances := len(r.FindingsPerIssue[issue.Identifier])
			buf.WriteString(fmt.Sprintf("| [%s](%s) | %s | %d |\n", issue.Identifier, issue.Link, issue.Title, instances))
		}

		buf.WriteString("\n")
	}

	buf.WriteString("## Files analyzed\n")
	for _, f := range r.FilesAnalyzed {
		buf.WriteString("- " + f + "\n")
	}
	buf.WriteString("\n")

	buf.WriteString("## Issues found\n")
	buf.WriteString("\n")
	for _, issue := range r.Issues {
		findings := r.FindingsPerIssue[issue.Identifier]
		if len(findings) == 0 {
			continue
		}

		buf.WriteString("### " + issue.Title + "\n")
		buf.WriteString("\n")

		// Impact
		buf.WriteString("#### Impact\n")
		buf.WriteString("Issue Information: [" + issue.Identifier + "]" + "(" + issue.Link + ")" + "\n")
		buf.WriteString("\n")

		// Findings
		buf.WriteString("#### Findings:\n")
		buf.WriteString("```\n")
		for _, finding := range findings {
			buf.WriteString(finding.String())
		}
		buf.WriteString("```\n")

		// Tools used
		buf.WriteString("#### Tools used\n")
		buf.WriteString("[c4udit](" + c4uditRepoLink + ")\n")

		buf.WriteString("\n")
	}

	return buf.String()
}

func (r Report) String() string {
	// Build files string.
	files := "Files analyzed:\n"
	for _, f := range r.FilesAnalyzed {
		files += fmt.Sprintf("- %s\n", f)
	}
	files += "\n"

	// Build issues string.
	issues := "Issues found:\n"
	for i, issue := range r.Issues {
		// Get findings for issue
		findings := r.FindingsPerIssue[issue.Identifier]

		// Skip if no findings
		if len(findings) == 0 {
			continue
		}

		// Add findings per issue
		issues += " " + issue.Identifier + ":\n"
		for _, finding := range findings {
			issues += "  " + finding.String()
		}

		// Add newline if not last issue
		if i+1 != len(r.Issues) {
			issues += "\n"
		}
	}

	return files + issues
}

func (i Issue) String() string {
	return i.Identifier
}

func (f Finding) String() string {
	return fmt.Sprintf("%s::%d => %s\n", f.File, f.LineNumber, f.LineContent)
}

func (s Severity) String() string {
	return []string{
		"Gas Optimization",
		"Non-Critical",
		"Low Risk",
		"Medium Risk",
		"High Risk",
	}[s]
}

func filterIssuesBySeverity(issues []Issue, severity Severity) []Issue {
	filtered := []Issue{}
	for _, issue := range issues {
		if issue.Severity == severity {
			filtered = append(filtered, issue)
		}
	}
	return filtered
}
